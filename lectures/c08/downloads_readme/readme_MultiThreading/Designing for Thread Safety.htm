<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://www.artima.com/designtechniques/threadsafetyP.html -->
<HTML><HEAD><TITLE>Designing for Thread Safety</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META 
content="Article describing how, why, and when to design&#10;thread safe objects in Java." 
name=description>
<META content="Java Design, Object Oriented Design,&#10;Thread Safety" 
name=keywords>
<META content="Bill Venners" name=author><LINK 
href="Designing for Thread Safety_files/artimapf.css" type=text/css 
rel=stylesheet><LINK href="/favicon.ico" rel="shortcut icon">
<META content="MSHTML 6.00.2900.3660" name=GENERATOR></HEAD>
<BODY>
<TABLE style="MARGIN-TOP: 5px" width="100%" bgColor=#ffffff>
  <TBODY>
  <TR>
    <TD align=middle>
      <DIV id=topbanner style="HEIGHT: 90px"><NOSCRIPT><A 
      href="http://www.artima.com/zcr/adclick.php?n=a86d37e9" target=_top><IMG 
      alt="" src="Designing for Thread Safety_files/lproginscalaebook.gif" 
      border=0></A></NOSCRIPT></DIV></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD vAlign=bottom align=left><A 
      href="http://www.artima.com/index.jsp"><IMG height=43 
      alt="The Artima Developer Community" 
      src="Designing for Thread Safety_files/a7.gif" width=550 border=0></A> 
  </TD></TR></TBODY></TABLE>
<TABLE width="100%" bgColor=#333333>
  <TBODY>
  <TR>
    <TD align=middle>
      <DIV class=ml><A class=hl 
      href="http://www.artima.com/articles">Articles</A>&nbsp;| <A class=hl 
      href="http://www.artima.com/news/index.jsp">News</A>&nbsp;| <A class=hl 
      href="http://www.artima.com/weblogs/index.jsp">Weblogs</A>&nbsp;| <A 
      class=hl href="http://www.artima.com/buzz/index.jsp">Buzz</A>&nbsp;| <A 
      class=hl 
      href="http://www.artima.com/chapters/index.jsp">Chapters</A>&nbsp;| <A 
      class=hl href="http://www.artima.com/forums/index.jsp">Forums</A> 
  </DIV></TD></TR></TBODY></TABLE>
<TABLE width="100%" bgColor=#aaccff>
  <TBODY>
  <TR>
    <TD align=middle>
      <DIV class=sc><A 
      href="http://www.artima.com/designtechniques/index.html">Design 
      Techniques</A>&nbsp;| <A 
      href="http://www.artima.com/designtechniques/booklist.html">Book 
      List</A>&nbsp;| Print&nbsp;| <A 
      href="mailto:?subject=Designing for Thread Safety&amp;body= Designing for Thread Safety Using Synchronization, Immutable Objects, and Thread-Safe Wrappers by Bill Venners http://www.artima.com/designtechniques/threadsafetyP.html">Email</A>&nbsp;| 
      <A href="http://www.artima.com/designtechniques/threadsafety.html">Screen 
      Friendly Version</A>&nbsp;| <A 
      href="http://www.artima.com/designtechniques/desexcept.html">Previous</A>&nbsp;| 
      <A href="http://www.artima.com/designtechniques/eventgen.html">Next</A> 
      </DIV></TD></TR></TBODY></TABLE>
<TABLE width="100%" bgColor=#eeeeee>
  <TBODY>
  <TR>
    <TD align=middle>
      <DIV class=sc><SPAN style="COLOR: #555555">Sponsored Link</SPAN> <SPAN 
      style="COLOR: #888888">•</SPAN>
      <SCRIPT language=JavaScript src="Designing for Thread Safety_files/adx.js" 
      type=text/javascript></SCRIPT>

      <SCRIPT language=JavaScript type=text/javascript>
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("http://www.artima.com/zcr/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</SCRIPT>
       <NOSCRIPT><A href="http://www.artima.com/zcr/adclick.php?n=a799ecf6" 
      target=_top><IMG alt="" src="Designing for Thread Safety_files/adview.gif" 
      border=0></A></NOSCRIPT> </DIV></TD></TR></TBODY></TABLE><BR>
<DIV class=vegies>
<DIV class=tc><SPAN class=ts>Designing for Thread Safety</SPAN><BR><SPAN 
class=sts>Using Synchronization, Immutable Objects, and Thread-Safe 
Wrappers</SPAN><BR><SPAN class=as>by Bill Venners</SPAN><BR><SPAN class=pd>First 
Published in <A href="http://www.javaworld.com/">JavaWorld</A>, July 
1998</SPAN><BR></DIV>
<BLOCKQUOTE><STRONG>Summary</STRONG><BR>This article gives you design 
  guidelines pertaining to thread safety. It provides a background on thread 
  safety and shows several examples of objects that are and are not thread-safe, 
  including two illustrative applets. In addition, the article offers guidelines 
  to help you decide when thread safety is appropriate and how best to achieve 
  it. </BLOCKQUOTE>
<P>
<HR width="100%">

<P><FONT size=+2><STRONG>S</STRONG></FONT>ix months ago I began a series of 
articles about designing classes and objects. In this month's <STRONG>Design 
Techniques</STRONG> column, I'll continue that series by looking at design 
principles that concern thread safety. This article tells you what thread safety 
is, why you need it, when you need it, and how to go about getting it. 
<P><FONT size=+1><STRONG>What is thread safety?</STRONG></FONT><BR>Thread safety 
simply means that the fields of an object or class always maintain a valid 
state, as observed by other objects and classes, even when used concurrently by 
multiple threads. 
<P>One of the first guidelines I proposed in this column (see "<A 
href="http://www.artima.com/designtechniques/desinit.html">Designing object 
initialization</A>") is that you should design classes such that objects 
maintain a valid state, from the beginning of their lifetimes to the end. If you 
follow this advice and create objects whose instance variables all are private 
and whose methods only make proper state transitions on those instance 
variables, you're in good shape in a single-threaded environment. But you may 
get into trouble when more threads come along. 
<P>Multiple threads can spell trouble for your object because often, while a 
method is in the process of executing, the state of your object can be 
temporarily invalid. When just one thread is invoking the object's methods, only 
one method at a time will ever be executing, and each method will be allowed to 
finish before another method is invoked. Thus, in a single-threaded environment, 
each method will be given a chance to make sure that any temporarily invalid 
state is changed into a valid state before the method returns. 
<P>Once you introduce multiple threads, however, the JVM may interrupt the 
thread executing one method while the object's instance variables are still in a 
temporarily invalid state. The JVM could then give a different thread a chance 
to execute, and that thread could call a method on the same object. All your 
hard work to make your instance variables private and your methods perform only 
valid state transformations will not be enough to prevent this second thread 
from observing the object in an invalid state. 
<P>Such an object would not be thread-safe, because in a multithreaded 
environment, the object could become corrupted or be observed to have an invalid 
state. A thread-safe object is one that always maintains a valid state, as 
observed by other classes and objects, even in a multithreaded environment. 
<P><FONT size=+1><STRONG>Why worry about thread safety?</STRONG></FONT><BR>There 
are two big reasons you need to think about thread safety when you design 
classes and objects in Java: 
<P>
<OL>
  <LI>Support for multiple threads is built into the Java language and API 
  <P></P>
  <LI>All threads inside a Java virtual machine (JVM) share the same heap and 
  method area </LI></OL>
<P>Because multithreading is built into Java, it is possible that any class you 
design eventually may be used concurrently by multiple threads. You needn't (and 
shouldn't) make every class you design thread-safe, because thread safety 
doesn't come for free. But you should at least <EM>think</EM> about thread 
safety every time you design a Java class. You'll find a discussion of the costs 
of thread safety and guidelines concerning when to make classes thread-safe 
later in this article. 
<P>Given the architecture of the JVM, you need only be concerned with instance 
and class variables when you worry about thread safety. Because all threads 
share the same heap, and the heap is where all instance variables are stored, 
multiple threads can attempt to use the same object's instance variables 
concurrently. Likewise, because all threads share the same method area, and the 
method area is where all class variables are stored, multiple threads can 
attempt to use the same class variables concurrently. When you do choose to make 
a class thread-safe, your goal is to guarantee the integrity -- in a 
multithreaded environment -- of instance and class variables declared in that 
class. 
<P>You needn't worry about multithreaded access to local variables, method 
parameters, and return values, because these variables reside on the Java stack. 
In the JVM, each thread is awarded its own Java stack. No thread can see or use 
any local variables, return values, or parameters belonging to another thread. 
<P>Given the structure of the JVM, local variables, method parameters, and 
return values are inherently "thread-safe." But instance variables and class 
variables will only be thread-safe if you design your class appropriately. 
<P><FONT size=+1><STRONG>RGBColor #1: Ready for a single 
thread</STRONG></FONT><BR>As an example of a class that is <EM>not</EM> 
thread-safe, consider the <CODE>RGBColor</CODE> class, shown below. Instances of 
this class represent a color stored in three private instance variables: 
<CODE>r</CODE>, <CODE>g</CODE>, and <CODE>b</CODE>. Given the class shown below, 
an <CODE>RGBColor</CODE> object would begin its life in a valid state and would 
experience only valid-state transitions, from the beginning of its life to the 
end -- but only in a single-threaded environment. 
<P><PRE>// In file threads/ex1/RGBColor.java
// Instances of this class are NOT thread-safe.
public class RGBColor {

    private int r;
    private int g;
    private int b;

    public RGBColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        this.r = r;
        this.g = g;
        this.b = b;
    }

    public void setColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        this.r = r;
        this.g = g;
        this.b = b;
    }

    /**
    * returns color in an array of three ints: R, G, and B
    */
    public int[] getColor() {

        int[] retVal = new int[3];
        retVal[0] = r;
        retVal[1] = g;
        retVal[2] = b;

        return retVal;
    }

    public void invert() {

        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
    }

    private static void checkRGBVals(int r, int g, int b) {

        if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 ||
            b &lt; 0 || b &gt; 255) {

            throw new IllegalArgumentException();
        }
    }
}
</PRE>
<P>Because the three instance variables, <CODE>int</CODE>s <CODE>r</CODE>, 
<CODE>g</CODE>, and <CODE>b</CODE>, are private, the only way other classes and 
objects can access or influence the values of these variables is via 
<CODE>RGBColor</CODE>'s constructor and methods. The design of the constructor 
and methods guarantees that: 
<P>
<OL>
  <LI><CODE>RGBColor</CODE>'s constructor will always give the variables proper 
  initial values 
  <P></P>
  <LI>Methods <CODE>setColor()</CODE> and <CODE>invert()</CODE> will always 
  perform valid state transformations on these variables 
  <P></P>
  <LI>Method <CODE>getColor()</CODE> will always return a valid view of these 
  variables </LI></OL>
<P>Note that if bad data is passed to the constructor or the 
<CODE>setColor()</CODE> method, they will complete abruptly with an 
<CODE>IllegalArgumentException</CODE>. The <CODE>checkRGBVals()</CODE> method, 
which throws this exception, in effect defines what it means for an 
<CODE>RGBColor</CODE> object to be valid: the values of all three variables, 
<CODE>r</CODE>, <CODE>g</CODE>, and <CODE>b</CODE>, must be between 0 and 255, 
inclusive. In addition, in order to be valid, the color represented by these 
variables must be the most recent color either passed to the constructor or 
<CODE>setColor()</CODE> method, or produced by the <CODE>invert()</CODE> method. 

<P>If, in a single-threaded environment, you invoke <CODE>setColor()</CODE> and 
pass in blue, the <CODE>RGBColor</CODE> object will be blue when 
<CODE>setColor()</CODE> returns. If you then invoke <CODE>getColor()</CODE> on 
the same object, you'll get blue. In a single-threaded society, instances of 
this <CODE>RGBColor</CODE> class are well-behaved. 
<P><FONT size=+1><STRONG>Throwing a concurrent wrench into the 
works</STRONG></FONT><BR>Unfortunately, this happy picture of a well-behaved 
<CODE>RGBColor</CODE> object can turn scary when other threads enter the 
picture. In a multithreaded environment, instances of the <CODE>RGBColor</CODE> 
class defined above are susceptible to two kinds of bad behavior: write/write 
conflicts and read/write conflicts. 
<P><STRONG>Write/write conflicts</STRONG><BR>Imagine you have two threads, one 
thread named "red" and another named "blue." Both threads are trying to set the 
color of the same <CODE>RGBColor</CODE> object: The red thread is trying to set 
the color to red; the blue thread is trying to set the color to blue. 
<P>Both of these threads are trying to write to the same object's instance 
variables concurrently. If the thread scheduler interleaves these two threads in 
just the right way, the two threads will inadvertently interfere with each 
other, yielding a write/write conflict. In the process, the two threads will 
corrupt the object's state. 
<P><STRONG>The <EM>Unsynchronized <CODE>RGBColor</CODE></EM> 
applet</STRONG><BR>The following applet, named <EM>Unsynchronized RGBColor</EM>, 
demonstrates one sequence of events that could result in a corrupt 
<CODE>RGBColor</CODE> object. The red thread is innocently trying to set the 
color to red while the blue thread is innocently trying to set the color to 
blue. In the end, the <CODE>RGBColor</CODE> object represents neither red nor 
blue but the unsettling color, magenta. 
<P>
<CENTER><APPLET codeBase=classes height=250 width=550 
code=UnsynchColorApplet.class>
For some reason, your browser won't let you see this way cool Javaapplet.
</APPLET> </CENTER>
<P>To step through the sequence of events that lead to a corrupted 
<CODE>RGBColor</CODE> object, press the applet's Step button. Press Back to back 
up a step, and Reset to back up to the beginning. As you go, a line of text at 
the bottom of the applet will explain what's happening during each step. 
<P>For those of you who can't run the applet, here's a table that shows the 
sequence of events demonstrated by the applet: 
<P>
<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD>Thread</TD>
    <TD>Statement</TD>
    <TD>r</TD>
    <TD>g</TD>
    <TD>b</TD>
    <TD>Color</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents green</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread invokes setColor(0, 0, 255)</FONT></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>checkRGBVals(0, 0, 255);</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.r = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.g = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue gets preempted</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread invokes setColor(255, 0, 0)</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>checkRGBVals(255, 0, 0);</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.r = 255;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.g = 0;</FONT></CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.b = 0;</FONT></CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread returns</FONT></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>later, blue thread continues</FONT></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.b = 255</FONT></CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread returns</FONT></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#ff00ff>&nbsp;</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents magenta</CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#ff00ff>&nbsp;</TD></TR></TBODY></TABLE></CENTER>
<P>As you can see from this applet and table, the <CODE>RGBColor</CODE> is 
corrupted because the thread scheduler interrupts the blue thread while the 
object is still in a temporarily invalid state. When the red thread comes in and 
paints the object red, the blue thread is only partially finished painting the 
object blue. When the blue thread returns to finish the job, it inadvertently 
corrupts the object. 
<P><FONT size=+1><STRONG>Read/write conflicts</STRONG></FONT><BR>Another kind of 
misbehavior that may be exhibited in a multithreaded environment by instances of 
this <CODE>RGBColor</CODE> class is read/write conflicts. This kind of conflict 
arises when an object's state is read and used while in a temporarily invalid 
state due to the unfinished work of another thread. 
<P>For example, note that during the blue thread's execution of the 
<CODE>setColor()</CODE> method above, the object at one point finds itself in 
the temporarily invalid state of black. Here, black is a temporarily invalid 
state because: 
<P>
<OL>
  <LI>It is temporary: Eventually, the blue thread intends to set the color to 
  blue. 
  <P></P>
  <LI>It is invalid: No one asked for a black <CODE>RGBColor</CODE> object. The 
  blue thread is supposed to turn a green object into blue. </LI></OL>
<P>If the blue thread is preempted at the moment the object represents black by 
a thread that invokes <CODE>getColor()</CODE> on the same object, that second 
thread would observe the <CODE>RGBColor</CODE> object's value to be black. 
<P>Here's a table that shows a sequence of events that could lead to just such a 
read/write conflict: 
<P>
<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD>Thread</TD>
    <TD>Statement</TD>
    <TD>r</TD>
    <TD>g</TD>
    <TD>b</TD>
    <TD>Color</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents green</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread invokes setColor(0, 0, 255)</FONT></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>checkRGBVals(0, 0, 255);</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.r = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.g = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue gets preempted</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread invokes getColor()</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>int[] retVal = new int[3];</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>retVal[0] = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>retVal[1] = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>retVal[2] = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>return retVal;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread returns black</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>later, blue thread continues</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.b = 255</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread returns</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents blue</CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR></TBODY></TABLE></CENTER>
<P>As you can see from this table, the trouble begins when the blue thread is 
interrupted when it has only partially finished painting the object blue. At 
this point the object is in a temporarily invalid state of black, which is 
exactly what the red thread sees when it invokes <CODE>getColor()</CODE> on the 
object. 
<P><FONT size=+1><STRONG>Three ways to make an object 
thread-safe</STRONG></FONT><BR>There are basically three approaches you can take 
to make an object such as <CODE>RGBThread</CODE> thread-safe: 
<P>
<OL>
  <LI>Synchronize critical sections 
  <LI>Make it immutable 
  <LI>Use a thread-safe wrapper </LI></OL>
<P><FONT size=+1><STRONG>Approach 1: Synchronizing the critical 
sections</STRONG></FONT><BR>The most straightforward way to correct the unruly 
behavior exhibited by objects such as <CODE>RGBColor</CODE> when placed in a 
multithreaded context is to synchronize the object's critical sections. An 
object's <EM>critical sections</EM> are those methods or blocks of code within 
methods that must be executed by only one thread at a time. Put another way, a 
critical section is a method or block of code that must be executed atomically, 
as a single, indivisible operation. By using Java's <CODE>synchronized</CODE> 
keyword, you can guarantee that only one thread at a time will ever execute the 
object's critical sections. 
<P>To take this approach to making your object thread-safe, you must follow two 
steps: you must make all relevant fields private, and you must identify and 
synchronize all the critical sections. 
<P><STRONG>Step 1: Make fields private</STRONG><BR>Synchronization means that 
only one thread at a time will be able to execute a bit of code (a critical 
section). So even though it's <EM>fields</EM> you want to coordinate access to 
among multiple threads, Java's mechanism to do so actually coordinates access to 
<EM>code.</EM> This means that only if you make the data private will you be 
able to control access to that data by controlling access to the code that 
manipulates the data. 
<P>The first rule to follow when making a class thread-safe through 
synchronizing its critical sections, therefore, is to make its fields private. 
Any field that you need to coordinate multithreaded access to must be private, 
otherwise it may be possible for other classes and objects to ignore your 
critical sections and access the fields directly. 
<P>Not every field must be private -- only those that will be involved in any 
temporarily invalid states created by the object's or class's critical sections. 
For example, constants (static final variables) can't be corrupted by multiple 
threads, so they needn't be private. 
<P><STRONG>Step 2: Identify and synchronize critical sections</STRONG><BR>Once 
you've made the appropriate variables private, you need only mark the object's 
critical sections as synchronized. As mentioned above, a <EM>critical 
section</EM>is a bit of code that must be executed atomically, that is, as a 
single, indivisible operation. For example, the statements: 
<P>
<BLOCKQUOTE><PRE>this.r = r;
this.g = g;
this.b = b;
</PRE></BLOCKQUOTE>
<P>must operate atomically for the <CODE>setColor()</CODE> method to behave as 
expected in a multithreaded environment. To ensure proper behavior, these three 
statements need to appear as if they were executed by a single, indivisible JVM 
instruction. 
<P>Note that reads and writes of primitive types and object references are 
atomic by definition, except for <CODE>long</CODE>s and <CODE>double</CODE>s. 
This means that if you have an <CODE>int</CODE>, for example, that is 
independent of any other fields in an object, you needn't synchronize code that 
accesses that field. If two threads were to attempt to write two different 
values to the <CODE>int</CODE> concurrently, the resulting value would be one or 
the other. The <CODE>int</CODE> would never end up with a corrupted value made 
up of some bits written by one thread and other bits written by the other 
thread. 
<P>The same is not necessarily true, however, for <CODE>long</CODE>s and 
<CODE>double</CODE>s. If two different threads were to attempt to write two 
different values to a <CODE>long</CODE> concurrently, you might just end up with 
a corrupted value consisting of some bits written by one thread and other bits 
written by the other thread. Multithreaded access to <CODE>long</CODE>s and 
<CODE>double</CODE>s, therefore, should always be synchronized. 
<P><STRONG>RGBColor # 2: Thread safety through 
synchronization</STRONG><BR>Here's a revised version of the 
<CODE>RGBColor()</CODE> class. This version, which has its critical sections 
marked as synchronized, is thread-safe: 
<P><PRE>// In file threads/ex2/RGBColor.java
// Instances of this class are thread-safe.
public class RGBColor {

    private int r;
    private int g;
    private int b;

    public RGBColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        this.r = r;
        this.g = g;
        this.b = b;
    }

    public void setColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        synchronized (this) {

            this.r = r;
            this.g = g;
            this.b = b;
        }
    }

    /**
    * returns color in an array of three ints: R, G, and B
    */
    public int[] getColor() {

        int[] retVal = new int[3];

        synchronized (this) {

            retVal[0] = r;
            retVal[1] = g;
            retVal[2] = b;
        }

        return retVal;
    }

    public synchronized void invert() {

        r = 255 - r;
        g = 255 - g;
        b = 255 - b;
    }

    private static void checkRGBVals(int r, int g, int b) {

        if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 ||
            b &lt; 0 || b &gt; 255) {

            throw new IllegalArgumentException();
        }
    }
}
</PRE>
<P><STRONG>The <EM>Synchronized <CODE>RGBColor</CODE></EM> 
applet</STRONG><BR>The following applet, named <EM>Synchronized RGBColor</EM>, 
demonstrates a similar sequence of events to the one that led to a corrupt 
<CODE>RGBColor</CODE> object in the previous demonstration applet. This applet, 
however, shows how the thread-safe version of <CODE>RGBColor</CODE> is able to 
maintain a valid state, even when multiple threads are attempting to write to 
the object. As before, a red thread is trying to set the color to red while a 
blue thread is trying to set the color to blue. In the end, this 
<CODE>RGBColor</CODE> object represents not the invalid color magenta, but the 
valid -- and satisfying -- color red. 
<P>
<CENTER><APPLET codeBase=classes height=250 width=550 
code=SynchColorApplet.class>
<P>For some reason, your browser won't let you see this way-cool Javaapplet.
</APPLET> </CENTER>
<P>To step through the sequence of events that led to a corrupted 
<CODE>RGBColor</CODE> object, press the applet's Step button. Press Back to back 
up a step, and Reset to back up to the beginning. As you go, a line of text at 
the bottom of the applet will explain what's happening during each step. 
<P>For those of you who can't run the applet, here's a table that shows the 
sequence of events demonstrated by the applet: 
<P>
<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD>Thread</TD>
    <TD>Statement</TD>
    <TD>r</TD>
    <TD>g</TD>
    <TD>b</TD>
    <TD>Color</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents green</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread invokes setColor(0, 0, 255)</FONT></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread acquires lock</FONT></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>checkRGBVals(0, 0, 255);</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.r = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.g = 0;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD bgColor=#00ff00>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue gets preempted</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread invokes setColor(255, 0, 0)</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread blocks because object locked</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>later, blue thread continues</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><CODE><FONT color=blue>this.b = 255</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#000000>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=blue>blue</FONT></TD>
    <TD><FONT color=blue>blue thread returns and releases lock</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>later, red thread acquires lock and 
continues</FONT></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>checkRGBVals(255, 0, 0);</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.r = 255;</FONT></CODE></TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#0000ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.g = 0;</FONT></CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#ff00ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><CODE><FONT color=red>this.b = 0;</FONT></CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>255</TD>
    <TD bgColor=#ff00ff>&nbsp;</TD></TR>
  <TR>
    <TD><FONT color=red>red</FONT></TD>
    <TD><FONT color=red>red thread returns and releases lock</FONT></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR>
  <TR>
    <TD>none</TD>
    <TD>object represents red</CODE></TD>
    <TD>255</TD>
    <TD>0</TD>
    <TD>0</TD>
    <TD bgColor=#ff0000>&nbsp;</TD></TR></TBODY></TABLE></CENTER>
<P>Note that this version of <CODE>RGBColor</CODE> still has temporarily invalid 
states from time to time. To be specific, at times during the sequence shown 
above this object's state does represent the invalid states black and magenta. 
The trick to synchronization is that while an object is having one of those 
temporarily invalid moments, no other classes or objects are allowed to use or 
observe the state of the object via other threads. 
<P><FONT size=+1><STRONG>Approach 2: Immutable objects</STRONG></FONT><BR>An 
alternative way to make an object thread-safe is to make the object immutable. 
An <EM>immutable object</EM> is one whose state can't be changed once the object 
is created. 
<P>Immutable objects are, by their very nature, thread-safe simply because 
threads have to be able to write to an object's instance variables to experience 
a read/write or write/write conflict. Because no methods (only the constructor) 
of an immutable object actually write to the object's instance variables, the 
object is by definition thread-safe. 
<P>In this approach to making an object thread-safe, you don't mark critical 
sections as synchronized. Instead, you separate out the critical sections that 
read instance variables from those that write to instance variables. The 
critical sections that read are left as-is. The critical sections that write 
must be changed so that, instead of altering the current object's instance 
variables, they create a new object that embodies the new state and returns a 
reference to that object. 
<P><FONT size=+1><STRONG>RGBColor # 3: Thread safety through 
immutability</STRONG></FONT><BR>Here's an immutable version of RGBColor: 
<P><PRE>// In file threads/ex3/RGBColor.java
// Instances of this immutable class
// are thread-safe.
public class RGBColor {

    private final int r;
    private final int g;
    private final int b;

    public RGBColor(int r, int g, int b) {

        checkRGBVals(r, g, b);

        this.r = r;
        this.g = g;
        this.b = b;
    }

    /**
    * returns color in an array of three ints: R, G, and B
    */
    public int[] getColor() {

        int[] retVal = new int[3];
        retVal[0] = r;
        retVal[1] = g;
        retVal[2] = b;

        return retVal;
    }

    public RGBColor invert() {

        RGBColor retVal = new RGBColor(255 - r,
            255 - g, 255 - b);

        return retVal;
    }

    private static void checkRGBVals(int r, int g, int b) {

        if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 ||
            b &lt; 0 || b &gt; 255) {

            throw new IllegalArgumentException();
        }
    }
}
</PRE>
<P>Note that the <CODE>setColor()</CODE> method is simply removed, as it doesn't 
make sense in an immutable <CODE>RGBColor</CODE> object. The 
<CODE>getColor()</CODE> method, which reads the instance variables, is identical 
to what it has been, except now it doesn't have to be synchronized. The 
<CODE>invert()</CODE> method, which writes to the instance variables, is 
changed. Instead of inverting the current object's color, this new 
<CODE>invert()</CODE> creates a new <CODE>RGBColor</CODE> object that represents 
the inverse of the object upon which <CODE>invert()</CODE> is invoked, and 
returns a reference to that object. 
<P><FONT size=+1><STRONG>Approach 3: Thread-safe wrappers</STRONG></FONT><BR>The 
third approach to making an object thread-safe is to embed that object in a 
thread-safe wrapper object. In this approach you leave the original class (which 
isn't thread-safe) unchanged and create a separate class that is thread-safe. 
Instances of the new class serve as thread-safe "front ends" to instances of the 
original class. 
<P><STRONG>SafeRGBColor: A thread-safe wrapper</STRONG><BR>Here's an example of 
this approach applied to the very first version of <CODE>RGBColor</CODE> 
presented in this article. 
<P><PRE>// In file threads/ex1/SafeRGBColor.java
// Instances of this class are thread-safe
// wrappers of RGBColor objects, which are
// not thread-safe.
public class SafeRGBColor {

    private RGBColor color;

    public SafeRGBColor(int r, int g, int b) {

        color = new RGBColor(r, g, b);
    }

    public synchronized void setColor(int r, int g, int b) {

        color.setColor(r, g, b);
    }

    /**
    * returns color in an array of three ints: R, G, and B
    */
    public synchronized int[] getColor() {

        return color.getColor();
    }

    public synchronized void invert() {

        color.invert();
    }
}
</PRE>
<P><FONT size=+1><STRONG>Why not just synchronize 
everything?</STRONG></FONT><BR>As mentioned earlier in this article, you don't 
want to make every class you design thread-safe -- only classes whose instances 
will be used concurrently by multiple threads. The reason you don't want to make 
every class thread-safe is that thread safety may involve a performance penalty. 
For example: 
<P>
<UL>
  <LI>Synchronized method invocations generally are going to be slower than 
  non-synchronized method invocations. In Sun's current JVM, for example, 
  synchronized method invocations are 4 to 6 times slower than non-synchronized 
  method invocations. In the future, the speed of synchronized method 
  invocations should improve, but they will likely never achieve parity with 
  non-synchronized method invocations. 
  <P></P>
  <LI>Unnecessary synchronized method invocations (and synchronized blocks) can 
  cause unnecessary blocking and unblocking of threads, which can hurt 
  performance. 
  <P></P>
  <LI>Immutable objects tend to be instantiated more often, leading to greater 
  numbers of often short-lived objects that can increase the work of the garbage 
  collector. 
  <P></P>
  <LI>Synchronization gives rise to the possibility of deadlock, a severe 
  performance problem in which your program appears to hang. </LI></UL>
<P>None of these performance setbacks are good excuses for neglecting to make 
classes that need to thread-safe so, but they do constitute good reasons not to 
make classes thread-safe unnecessarily. 
<P><FONT size=+1><STRONG>Pros and cons of the three approaches to thread 
safety</STRONG></FONT><BR><STRONG>Synchronizing critical 
sections</STRONG><BR>Marking your code's critical sections as synchronized is 
the "normal" approach to making classes synchronized. It is also the only way to 
use <CODE>wait()</CODE> and <CODE>notify()</CODE> to get threads to cooperate 
towards achieving some common goal. So the guideline concerning Approach 1 is 
simply: 
<P>
<BLOCKQUOTE>Unless special circumstances make it appropriate to use an 
  immutable or wrapper object, use Approach 1 to make your class thread-safe: 
  Make sure the appropriate instance variables are private and mark the critical 
  sections as synchronized.</BLOCKQUOTE>
<P><STRONG>Using immutable objects</STRONG><BR>Achieving thread safety by making 
objects immutable (Approach 2) works well when objects are small and represent 
values of a simple abstract data type. The Java API includes several examples of 
immutable objects, including <CODE>String</CODE> and the primitive type wrappers 
such as <CODE>Integer</CODE>, <CODE>Long</CODE>, <CODE>Float</CODE>, 
<CODE>Boolean</CODE>, <CODE>Character</CODE>, and so on. 
<P>It's worth noting that instances of the AWT's <CODE>Color</CODE> class are 
immutable. Likewise, the immutable approach may make sense for this article's 
<CODE>RGBColor</CODE> class, which is similar in functionality to the AWT's 
<CODE>Color</CODE> class, because <CODE>RGBColor</CODE> objects are small (they 
contain only 3 <CODE>int</CODE>s) and conceptually represent values of a simple 
abstract data type. 
<P>Another benefit of immutable objects is that you can pass references to them 
to methods without worrying that the method will change the object's state. In 
addition, if the overhead of immutability (excessive creation of short-lived 
objects) may at times be too inefficient, you can also define a mutable 
companion class that can be used when the immutable version isn't appropriate. 
An example of this design approach in the Java API is the 
<CODE>StringBuffer</CODE> class, which serves as a mutable companion to the 
immutable <CODE>String</CODE> class. Note that the <CODE>StringBuffer</CODE> 
class is also thread-safe, but it uses the "normal" approach: its instance 
variables are private and its critical sections are synchronized. 
<P><STRONG>Using wrapper objects</STRONG><BR>The wrapper object approach to 
thread safety (Approach 3) makes the most sense when you want to give clients a 
choice between a version of a class that is thread-safe and one that isn't. This 
approach also makes sense when you're a client of someone else's class that 
isn't thread-safe, but you need to use the class in a multithreaded environment. 
Once you define your own thread-safe wrapper for the class, you can safely use 
the class in a multithreaded environment by going through your wrapper. 
<P>A good example of this approach from the Java API comes from the 1.2 
collections library. The 1.2 collections library defines a hierarchy that 
includes classes that represent many kinds of collections -- none of which are 
thread-safe. But class <CODE>Collection</CODE> includes several class methods 
that will enclose a regular collection object in a thread-safe wrapper, so you 
can safely use the object in a multithreaded context. This design gives users of 
the collections library a choice of using a collections object that is 
thread-safe and one that isn't. 
<P>Note that a common attribute of wrapper classes like those you would use to 
add thread safety to the enclosed object is that the wrapper accepts the same 
messages as the enclosed object. In other words, often a wrapper class will 
descend from a common superclass or superinterface with the enclosed class. (For 
those of you familiar with the <EM>Design Patterns</EM> book by Gamma, et. al., 
this is the "decorator" pattern. See <A 
href="http://www.artima.com/designtechniques/threadsafetyP.html#resources">Resources</A> 
for more information on this book.) This decorator design approach to wrappers, 
which is exhibited by the thread-safe wrappers of the 1.2 collections library, 
allows the thread safety to be dynamically added or removed from an object. 
<P>The advantage of the approach to wrapping taken by <CODE>SafeRGBColor</CODE> 
in this article is that thread safety is guaranteed when using a 
<CODE>SafeRGBColor</CODE> object, because the enclosed <CODE>RGBColor</CODE> 
object is created by <CODE>SafeRGBColor</CODE>'s constructor and never returned 
by its own methods or passed to another object's methods. The decorator design 
approach, because the enclosed object is instantiated by the client and passed 
to the constructor of the thread-safe wrapper, requires that clients create the 
enclosed objects themselves first. Thus, to achieve thread safety, the decorator 
approach requires that clients have the discipline not to use the enclosed 
object except through the thread-safe wrapper. 
<P><FONT size=+1><STRONG>When to make classes 
thread-safe</STRONG></FONT><BR>When you are designing the classes that compose a 
Java applet or application, your thread-safety decision should be based simply 
on whether or not each class will be exposed to potential write/write or 
read/write conflicts by your programs. To know whether or not such conflicts are 
possible, you just have to know how your program will work. 
<P>For example, I didn't choose thread safety for any of the classes that 
compose the two simulation applets included above in this article, because they 
won't be exposed to multiple threads. Once the <CODE>init()</CODE> method of the 
applet has returned, the only thread that will be coursing through the veins of 
this code is the GUI event handler thread -- and there is only one GUI event 
handler thread. As a result, even if a user frantically clicks the Reset button 
as quickly as possible after the Step button, the code of my applet will handle 
the Step button press completely before beginning to handle the Reset button 
press. 
<P>By contrast, I did make thread-safe certain classes that compose the JVM 
Simulation applets that are delivered on the CD-ROM of my JVM book (see <A 
href="http://www.artima.com/designtechniques/threadsafetyP.html#resources">Resources</A>). 
These applets have Run and Stop buttons as well as Step and Reset buttons. When 
the user clicks Run, I fire off a thread that animates the applet, making the 
applet run as if the user were clicking Step about twice a second. When the user 
clicks Stop, the event handler thread comes in to stop the animation thread but 
mustn't be allowed to do so before the run thread completes its current step and 
puts the JVM simulator into a valid state. 
<P>If, instead of creating classes for an applet or application, you are 
creating classes for a library, either one that will be shared in-house or will 
serve as a product in its own right, you have a different problem. You may not 
know exactly how the classes will be used. In such cases, it may be a good idea 
to give clients a choice via the thread-safe wrapper approach. 
<P><FONT size=+1><STRONG>Conclusion</STRONG></FONT><BR>The most important point 
to take away from this article is that when programming in Java, you should at 
least <EM>think</EM> about thread safety every time you design a class. 
<P>Here's a collection of the exception guidelines put forth by this article: 
<P>
<UL>
  <LI>Given that thread safety can have a performance cost, don't make every 
  class thread-safe -- only those classes that will actually be used 
  concurrently by multiple threads 
  <P></P>
  <LI>Don't avoid making classes thread-safe that need to be thread-safe out of 
  fear of a performance impact 
  <P></P>
  <LI>When making an object thread-safe via Approach 1, synchronize only the 
  critical sections of the class 
  <P></P>
  <LI>Use an immutable object especially if the object is small or represents a 
  fundamental data type 
  <P></P>
  <LI>If you can't change a non-thread-safe class, use a wrapper object 
  <P></P>
  <LI>If you are creating a library of classes that will be used in both 
  thread-safe and non-thread-safe requirements, consider making wrappers an 
  option </LI></UL>
<P><FONT size=+1><STRONG>Next month</STRONG></FONT><BR>In next month's 
installment of <STRONG>Design Techniques</STRONG>, I'll continue the series of 
articles that focus on designing classes and objects. Next month's article, the 
seventh of this series, will discuss design guidelines that pertain to making an 
object observable. 
<P><FONT size=+1><STRONG>A request for reader participation</STRONG></FONT><BR>I 
encourage your comments, criticisms, suggestions, flames -- all kinds of 
feedback -- about the material presented in this column. If you disagree with 
something, or have something to add, please let me know. 
<P>You can either participate in a <A 
href="http://www.artima.com/flexiblejava/fjf/threadsafety/index.html">discussion 
forum</A> devoted to this material or e-mail me directly at <A 
href="mailto:bv@artima.com">bv@artima.com</A>. 
<P><A name=resources><STRONG>Resources</STRONG></A> 
<UL>
  <LI>The discussion forum devoted to the material presented in this 
  article.<BR><A 
  href="http://www.artima.com/flexiblejava/fjf/threadsafety/index.html">http://www.artima.com/flexiblejava/fjf/threadsafety/index.html</A> 

  <LI>Recommended books on Java design<BR><A 
  href="http://www.artima.com/designtechniques/booklist.html">http://www.artima.com/designtechniques/booklist.html</A> 

  <LI>Source packet that contains the example code used in this article<BR><A 
  href="http://www.artima.com/flexiblejava/code.html">http://www.artima.com/flexiblejava/code.html</A> 

  <LI>Source code for the JVM Simulator applets, which, as mentioned in the 
  article, include some thread-safe classes. Look at <CODE>JVMSimulator</CODE> 
  and <CODE>Method.java</CODE> and search for <CODE>sychronized</CODE>.<BR><A 
  href="http://www.artima.com/insidejvm/applets/sourcecode.html">http://www.artima.com/insidejvm/applets/sourcecode.html</A> 

  <LI>Object orientation FAQ<BR><A 
  href="http://www.cyberdyne-object-sys.com/oofaq/">http://www.cyberdyne-object-sys.com/oofaq/</A> 

  <LI>7237 Links on Object Orientation<BR><A 
  href="http://www.rhein-neckar.de/~cetus/software.html">http://www.rhein-neckar.de/~cetus/software.html</A> 

  <LI>The Object-Oriented Page<BR><A 
  href="http://www.well.com/user/ritchie/oo.html">http://www.well.com/user/ritchie/oo.html</A> 

  <LI>Collection of information on OO approach<BR><A 
  href="http://arkhp1.kek.jp/managers/computing/activities/OO_CollectInfor/OO_CollectInfo.html">http://arkhp1.kek.jp/managers/computing/activities/OO_CollectInfor/OO_CollectInfo.html</A> 

  <LI>Design Patterns Home Page<BR><A 
  href="http://hillside.net/patterns/patterns.html">http://hillside.net/patterns/patterns.html</A> 

  <LI>A Comparison of OOA and OOD Methods<BR><A 
  href="http://www.iconcomp.com/papers/comp/comp_1.html">http://www.iconcomp.com/papers/comp/comp_1.html</A> 

  <LI>Object-Oriented Analysis and Design Methods: A Comparative Review<BR><A 
  href="http://wwwis.cs.utwente.nl:8080/dmrg/OODOC/oodoc/oo.html">http://wwwis.cs.utwente.nl:8080/dmrg/OODOC/oodoc/oo.html</A> 

  <LI>Patterns discussion FAQ<BR><A 
  href="http://gee.cs.oswego.edu/dl/pd-FAQ/pd-FAQ.html">http://gee.cs.oswego.edu/dl/pd-FAQ/pd-FAQ.html</A> 

  <LI>Implementing Basic Design Patterns in Java (Doug Lea)<BR><A 
  href="http://www.oswego.edu/dl/pats/ifc.html">http://www.oswego.edu/dl/pats/ifc.html</A> 

  <LI>Patterns in Java AWT<BR><A 
  href="http://mordor.cs.hut.fi/tik-76.278/group6/awtpat.html">http://mordor.cs.hut.fi/tik-76.278/group6/awtpat.html</A> 

  <LI>Software Technology's Design Patterns Page<BR><A 
  href="http://www.sw-technologies.com/dpattern/">http://www.sw-technologies.com/dpattern/</A> 

  <LI>Previous <STRONG>Design Techniques</STRONG> articles<BR><A 
  href="http://www.javaworld.com/topicalindex/jw-ti-techniques.html">http://www.javaworld.com/topicalindex/jw-ti-techniques.html</A> 
  </LI></UL>
<P><STRONG>About the author</STRONG><BR>Bill Venners has been writing software 
professionally for 12 years. Based in Silicon Valley, he provides software 
consulting and <A 
href="http://www.artima.com/javaseminars/index.html">training</A> services under 
the name <A href="http://www.artima.com/">Artima Software Company</A>. Over the 
years he has developed software for the consumer electronics, education, 
semiconductor, and life insurance industries. He has programmed in many 
languages on many platforms: assembly language on various microprocessors, C on 
Unix, C++ on Windows, Java on the Web. He is author of the book: <A 
href="http://www.artima.com/insidejvm/blurb.html"><EM>Inside the Java Virtual 
Machine</EM></A>, published by McGraw-Hill. Reach Bill at <A 
href="http://www.artima.com/designtechniques/bv@artima.com">http://www.artima.com/designtechniques/bv@artima.com</A>. 

<P>This article was first published under the name <A 
href="http://www.javaworld.com/javaworld/jw-08-1998/jw-08-techniques.html">Design 
for Thread Safety</A> in <STRONG>JavaWorld</STRONG>, a division of Web 
Publishing, Inc., July 1998. 
<P>
<CENTER>
<DIV class=sc><A href="http://www.artima.com/designtechniques/index.html">Design 
Techniques</A>&nbsp;| <A 
href="http://www.artima.com/designtechniques/booklist.html">Book List</A>&nbsp;| 
Print&nbsp;| <A 
href="mailto:?subject=Designing for Thread Safety&amp;body= Designing for Thread Safety Using Synchronization, Immutable Objects, and Thread-Safe Wrappers by Bill Venners http://www.artima.com/designtechniques/threadsafetyP.html">Email</A>&nbsp;| 
<A href="http://www.artima.com/designtechniques/threadsafety.html">Screen 
Friendly Version</A>&nbsp;| <A 
href="http://www.artima.com/designtechniques/desexcept.html">Previous</A>&nbsp;| 
<A href="http://www.artima.com/designtechniques/eventgen.html">Next</A> 
</DIV></CENTER></DIV>
<HR width="100%">

<TABLE width="50%" align=center>
  <TBODY>
  <TR>
    <TD>
      <DIV class=horizontaltextadbox>
      <DIV class=adheadline>Sponsored Links</DIV>
      <DIV id=sponsoredlinks></DIV></DIV></TD></TR></TBODY></TABLE>
<HR width="100%">

<DIV class=sp>
<DIV style="TEXT-ALIGN: center"><A 
href="http://www.artima.com/copyright.html">Copyright</A> © 1996-2009 Artima, 
Inc. All Rights Reserved.</A> - <A 
href="http://www.artima.com/privacy.html">Privacy Policy</A> - <A 
href="http://www.artima.com/termsofuse.html">Terms of Use</A> - <A 
href="http://www.artima.com/advertising.html">Advertise with Us</A> 
</DIV></DIV><BR>
<SCRIPT language=JavaScript type=text/javascript>
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = 'http://www.artima.com/zcr/' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</SCRIPT>

<SCRIPT language=JavaScript type=text/javascript>
<!--
initBannerVarForZone(1);
-->
</SCRIPT>

<SCRIPT language=JavaScript type=text/javascript>
<!--
replaceDiv('topbanner');
-->
</SCRIPT>

<SCRIPT language=JavaScript type=text/javascript>
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</SCRIPT>

<SCRIPT language=JavaScript type=text/javascript>
<!--
replaceDiv('sponsoredlinks');
-->
</SCRIPT>
</BODY></HTML>
