<html><head><title>http://www.javaworld.com/javaworld/javaqa/2001-05/02-qa-0511-factory.html</title>
<!-- base href="http://www.javaworld.com/javaworld/javaqa/2001-05/02-qa-0511-factory.html" --></head><body bgcolor="#ffffff">
<font size="1">Sponsored by:</font><br>
<a href="http://ad.doubleclick.net/jump/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1174241560?">
<img src="x_java.cgi_files/jw_printer.jpg" border="0" height="90" width="728"></a>
<p>
<img src="x_java.cgi_files/javaworld.gif" alt="From JavaWorld:" height="57" width="173"><br>
<br>
<font size="-1">This story appeared on JavaWorld at<br>
http://www.javaworld.com/javaworld/javaqa/2001-05/02-qa-0511-factory.html</font></p><p>
                     
                     <!--startindex-->
                     <a id="top" name="top"></a></p><h1>Factory methods</h1>
                     <h3>How do you employ factory methods to your best advantage?</h3>
                     <p class="byline">By&nbsp;Tony Sintes,&nbsp;JavaWorld.com,&nbsp;05/11/01</p>
                     
                     <!-- CONTENT GOES HERE-->
                     
<!--#set var="pages" value="2" -->
<!--#include virtual="/cgi-bin/pgnav05.pl?pageof=yes&pages=${pages}&${compare}" -->
<!--#if expr="${compare} = /^page\=1$/ || ${compare} = /^page\=full/" -->
                     <p class="first"><img alt="Q" src="x_java.cgi_files/q.gif" align="left" height="24" width="28"> <strong>While going through "<a href="http://www.javaworld.com/javaworld/javaqa/2000-12/01-qa-1208-abstract.html">Polymorphism in its purest form</a>," I saw the unfamiliar term <em>factory method.</em> Could you please describe what a factory method is and explain how I can use it?</strong></p>
                     <p><img alt="A" src="x_java.cgi_files/a.gif" align="left" height="24" width="26"> Factory method is just a fancy name for a method that instantiates objects. Like a factory, the job of the factory method
                        is to create -- or manufacture -- objects.
                     </p>
                     <p>Let's consider an example.</p>
                     <p>Every program needs a way to report errors. Consider the following interface:</p>
                     <p><strong>Listing 1</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(11);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap11"><pre>public interface Trace {
      // turn on and off debugging
      public void setDebug( boolean debug );
      // write out a debug message
      public void debug( String message );
      // write out an error message
      public void error( String message );
}
</pre></div>
                     </div><br><br> 
                     <p>Suppose that you've written two implementations. One implementation (Listing 2) writes the messages out to the command line,
                        while another (Listing 3) writes them to a file.
                     </p>
                     <p><strong>Listing 2</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(17);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap17"><pre>public class FileTrace implements Trace {
          
      private java.io.PrintWriter pw;
      private boolean debug;
      public FileTrace() throws java.io.IOException {
            // a real FileTrace would need to obtain the filename somewhere
            // for the example I'll hardcode it
            pw = new java.io.PrintWriter( new java.io.FileWriter( "c:\trace.log" ) );
      }
      public void setDebug( boolean debug ) {
            this.debug = debug;
      }
      public void debug( String message ) {
            if( debug ) {  // only print if debug is true
                  pw.println( "DEBUG: " + message );
                  pw.flush();
            }
      }
      public void error( String message ) {
            // always print out errors
            pw.println( "ERROR: " + message );
            pw.flush();
      }
}
</pre></div>
                     </div><br><br> 
                     <p><strong>Listing 3</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(22);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap22"><pre>public class SystemTrace implements Trace {
      private boolean debug;
      public void setDebug( boolean debug ) {
            this.debug = debug;
      }
      public void debug( String message ) {
            if( debug ) {  // only print if debug is true
                  System.out.println( "DEBUG: " + message );
            }
      }
      public void error( String message ) {
            // always print out errors
            System.out.println( "ERROR: " + message );
      }
}
</pre></div>
                     </div><br><br> 
                     <p>To use either of these classes, you would need to do the following:</p>
                     <p><strong>Listing 4</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(28);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap28"><pre>//... some code ...
SystemTrace log = new SystemTrace();
//... code ...
log.debug( "entering loog" );
// ... etc ...
</pre></div>
                     </div><br><br> 
                     <p>Now if you want to change the <code>Trace</code> implementation that your program uses, you'll need to edit each class that instantiates a <code>Trace</code> implementation. Depending upon the number of classes that use <code>Trace</code>, it might take a lot of work for you to make the change. Plus, you want to avoid altering your classes as much as possible.
                     </p>
                     <p>A factory method lets us be a lot smarter about how our classes obtain <code>Trace</code> implementation instances:
                     </p>
                     <p><strong>Listing 5</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(39);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap39"><pre>public class TraceFactory {
      public static Trace getTrace() {
            return new SystemTrace();
      }
}
</pre></div>
                     </div><br><br> 
                     <p><code>getTrace()</code> is a factory method. Now, whenever you want to obtain a reference to a <code>Trace</code>, you can simply call <code>TraceFactory.getTrace()</code>:
                     </p>
                     <p><strong>Listing 6</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(48);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap48"><pre>//... some code ...
Trace log = new TraceFactory.getTrace();
//... code ...
log.debug( "entering loog" );
// ... etc ...
</pre></div>
                     </div><br><br> 
                     <p>Using a factory method to obtain an instance can save you a lot of work later. In the code above, <code>TraceFactory</code> returns <code>SystemTrace</code>
instances. Imagine again that your requirements change and that you
need to write your messages out to a file. However, if you use a
factory method to obtain your instance, you need to make only one
change in one class in order to meet the new requirements. You do not
need to make changes in every class that uses <code>Trace</code>. Instead you can simply redefine <code>getTrace()</code>:
                        <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->
                     </p>
<!--#endif -->
<!--#if expr="${compare} = /^page\=2$/ || ${compare} = /^page\=full/" -->
                     <p><strong>Listing 7</strong></p>
                     <div id="codebutton"><input name="btn" value="Copy to Clipboard" onclick="HighlightText(58);" type="button"></div>
                     <div id="codewrap">
                        <div id="codewrap58"><pre>public class TraceFactory {
      public static Trace getTrace() {
            try {
                  return new FileTrace();
            } catch ( java.io.IOException ex ) {
                  Trace t = new SystemTrace();
                  t.error( "could not instantiate FileTrace: " + ex.getMessage() );
                  return t;
            }
      }
}
</pre></div>
                     </div><br><br> 
                     <p>Further, factory methods prove useful when you're not sure what concrete implementation of a class to instantiate. Instead,
                        you can leave those details to the factory method.
                     </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->
                     <p>In the above examples your program didn't know whether to create <code>FileTrace</code> or <code>SystemTrace</code> instances. Instead, you can program your objects to simply use <code>Trace</code> and leave the instantiation of the concrete implementation to a factory method.
                     </p>
                     <h3>Author Bio</h3>Tony Sintes is a principal consultant at BroadVision. A Sun-certified
                     Java 1.1 programmer and Java 2 developer, he has worked with Java
                     since 1997.
<!--#endif -->
<!--#include virtual="/includes/global-pgnav.html" -->
                     
                     <p>
<font size="-1">All contents copyright 1995-2007 Java World, Inc. <a href="http://www.javaworld.com/">http://www.javaworld.com</a></font>

</p></body></html>